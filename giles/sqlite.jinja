{######################################################################
 #
 # $Id: 8ff477f206c5ce01836efa3ac97ed15c4b06072f $
 #
 ######################################################################
 #
 # Copyright 2011-2014 KoreLogic, Inc. All Rights Reserved.
 #
 # This software, having been partly or wholly developed and/or
 # sponsored by KoreLogic, Inc., is hereby released under the terms
 # and conditions set forth in the project's "README.LICENSE" file.
 # For a list of all contributors and sponsors, please refer to the
 # project's "README.CREDITS" file.
 #
 ######################################################################
 #
 # Purpose: Generate a SQLite schema for Giles.
 #
 ######################################################################}

/*-
 **********************************************************************
 *
 * This file was automatically generated by the Giles production
 * system compiler. Editing by hand is not recommended.
 *
 * Input file list:     {{file}}
 * Compilation Started: {{time}}
 * Description:         {{description}}
 *
 **********************************************************************
 */

{# Create an fact table for every fact type. #}
{% for fact_name, fact_clause in facts|dictsort %}
  {# The actual facts table. This is a backing table; the user interacts with a view onto this table. #}
  CREATE TABLE {{prefix}}_{{fact_name}}_actual
  (
    {% for field_name, field_type in fact_clause|dictsort %}
      {% if field_type == bool %}
        {{field_name}} INTEGER NOT NULL
                               CONSTRAINT {{prefix}}_{{fact_name}}_{{field_name}}_valid_boolean
                               CHECK(CAST({{field_name}} AS INTEGER) IN (0, 1) AND CAST(CAST({{field_name}} AS INTEGER) AS TEXT) = CAST({{field_name}} AS TEXT)),

      {% elif  field_type == int %}
        {{field_name}} INTEGER NOT NULL
                               CONSTRAINT {{prefix}}_{{fact_name}}_{{field_name}}_valid_int
                               CHECK(CAST(CAST({{field_name}} AS INTEGER) AS TEXT) = CAST({{field_name}} AS TEXT)),

      {% elif field_type == float %}
        {{field_name}} REAL NOT NULL
                            CONSTRAINT {{prefix}}_{{fact_name}}_{{field_name}}_valid_real
                            CHECK(CAST(CAST({{field_name}} AS REAL) AS TEXT) = CAST({{field_name}} AS TEXT)),
      {% elif field_type == str %}
        {{field_name}} TEXT NOT NULL,
      {% endif %}
    {% endfor %}

    suppressed INTEGER, {# Temporary suppression flag, set during mark-and-sweep. #}
    rule       TEXT,
    frame      INTEGER,
    id         INTEGER PRIMARY KEY {% if fact_clause.is_output %} AUTOINCREMENT {% endif %}

    {% if fact_name in parameters %}
      {% if parameters[fact_name].dictionary %}
        , CONSTRAINT {{prefix}}_{{fact_name}}_unique_keys UNIQUE(key)
        , CONSTRAINT {{prefix}}_{{fact_name}}_nonempty_keys CHECK(LENGTH(key) > 0)
      {% endif %}
      {% if parameters[fact_name].lower is not none %}
        ,
        CONSTRAINT {{prefix}}_{{fact_name}}_lower_limit CHECK(value >= {{generate_expression(parameters[fact_name].lower, fact_name, None, None)}}),
        CONSTRAINT {{prefix}}_{{fact_name}}_upper_limit CHECK(value <= {{generate_expression(parameters[fact_name].upper, fact_name, None, None)}})
      {% endif %}
    {% endif %}
  );

  {# Alpha pruning - prune away any facts that can't possibly match. 
   # Howver, don't prune output facts as they are presumably interesting to the user even if they're not interesting to
   # other rules. #}
  {% if fact_name not in parameters and not fact_clause.is_output %}
    CREATE TRIGGER {{prefix}}_{{fact_name}}_fact_alpha_pruning BEFORE INSERT ON {{prefix}}_{{fact_name}}_actual
    WHEN
     NOT
     (
       {% for rule_name, rule_clause in rules|dictsort %}
         {% for match_clause in rule_clause.matches %}
           {% if match_clause.fact == fact_name %}
             {# Only spit out each test once. #}
             {{only_once(fact_name ~ "_fact_alpha_pruning", "(" ~ generate_predicate(match_clause.fact, match_clause.when) ~ ") OR ")}}
           {% endif %}
         {% endfor %}
         {% for match_clause in rule_clause.inverted_matches %}
           {% if match_clause.fact == fact_name %}
             {# Only spit out each test once. #}
             {{only_once(fact_name ~ "_fact_alpha_pruning", "(" ~ generate_predicate(match_clause.fact, match_clause.when) ~ ") OR ")}}
           {% endif %}
         {% endfor %}
       {% endfor %}
       0
     )
    BEGIN
      SELECT RAISE(IGNORE);
    END;
  {% endif %}

  {# These indexes are used to retract facts when their frames are gone. #}
  CREATE INDEX {{prefix}}_{{fact_name}}_suppressed ON {{prefix}}_{{fact_name}}_actual(suppressed);
  CREATE INDEX {{prefix}}_{{fact_name}}_rule_frame ON {{prefix}}_{{fact_name}}_actual(rule, frame);

  {# The shadow table that stores facts that are being suppressed. #}
  CREATE TABLE {{prefix}}_{{fact_name}}_shadow
  (
    {% for field_name, field_type in fact_clause|dictsort %}
      {% if field_type == bool or field_type == int %}
        {{field_name}} INTEGER,
      {% elif field_type == float %}
        {{field_name}} REAL,
      {% else %}
        {{field_name}} TEXT,
      {% endif %}
    {% endfor %}

    suppressing_rule  TEXT,
    suppressing_frame INTEGER,

    rule      TEXT,
    frame     INTEGER
  );

  {# These indexes are used to retract or revive facts when their frames are gone. #}
  CREATE INDEX {{prefix}}_{{fact_name}}_shadow_suppressing_rule_frame ON {{prefix}}_{{fact_name}}_shadow(suppressing_rule, suppressing_frame);
  CREATE INDEX {{prefix}}_{{fact_name}}_shadow_rule_frame             ON {{prefix}}_{{fact_name}}_shadow(rule, frame);

  {# The user-visible version of the facts table is prettier, lacking any administrative fields and prfacting undefined operations. #}
  CREATE VIEW {{public_prefix}}_{{fact_name}}_facts AS
    SELECT
      {% for field_name, field_type in fact_clause|dictsort %}
        {{field_name}},
      {% endfor %}
      id
    FROM
      {{prefix}}_{{fact_name}}_actual
    ;

  CREATE TRIGGER {{prefix}}_{{fact_name}}_facts_prfact_update INSTEAD OF UPDATE ON {{public_prefix}}_{{fact_name}}_facts
  BEGIN
    SELECT RAISE(ROLLBACK, 'Facts cannot be modified in place.');
  END;

  CREATE TRIGGER {{prefix}}_{{fact_name}}_facts_do_insert INSTEAD OF INSERT ON {{public_prefix}}_{{fact_name}}_facts
  BEGIN
    INSERT INTO {{prefix}}_{{fact_name}}_actual
    (
      {% set comma = joiner(",") %}
      {% for field_name, field_type in fact_clause|dictsort %}
        {{comma()}}
        {{field_name}}
      {% endfor %}
    )
    VALUES
    (
      {% set comma = joiner(",") %}
      {% for field_name, field_type in fact_clause|dictsort %}
        {{comma()}}
        new.{{field_name}}
      {% endfor %}
    );
  END;

  CREATE TRIGGER {{prefix}}_{{fact_name}}_facts_do_delete INSTEAD OF DELETE ON {{public_prefix}}_{{fact_name}}_facts
  BEGIN
    DELETE FROM {{prefix}}_{{fact_name}}_actual WHERE id = old.id AND frame IS NULL;
  END;

  CREATE TRIGGER {{prefix}}_{{fact_name}}_facts_do_delete_prfact INSTEAD OF DELETE ON {{public_prefix}}_{{fact_name}}_facts
  WHEN
    EXISTS (SELECT 1 FROM {{prefix}}_{{fact_name}}_actual WHERE id = old.id AND  frame IS NOT NULL)
  BEGIN
    SELECT RAISE(ROLLBACK, 'Cannot delete internal facts.');
  END;

{% endfor %}

{# Create a parameters view for the ease of setting parameters. #}
{% if parameters|count > 0 %}
  CREATE VIEW {{public_prefix}}_parameters AS
    {% set union = joiner(" UNION ") %}
    {% for parameter_name, parameter_clause in parameters|dictsort %}
      {{union()}}
      SELECT
        '{{parameter_name}}' AS Name,
        {% if parameter_clause.dictionary %}
          Key,
        {% else %}
          NULL AS Key,
        {% endif %}
        {% if facts[parameter_name].value == bool %}
          'BOOLEAN' AS Type,
        {% elif facts[parameter_name].value == int %}
          'INTEGER' AS Type,
        {% elif facts[parameter_name].value == float %}
          'REAL' AS Type,
        {% else %}
          'TEXT' AS Type,
        {% endif %}
        Value
      FROM
        {{prefix}}_{{parameter_name}}_actual
    {% endfor %}
    ;

  {# Make sure parameter inserts and updates are valid. #}
  CREATE TRIGGER {{prefix}}_valid_parameter_name_insert INSTEAD OF INSERT ON {{public_prefix}}_parameters
  WHEN
    {% for parameter_name, parameter_clause in parameters|dictsort %}
      new.name != '{{parameter_name}}'
      AND
    {% endfor %}
    1
  BEGIN
    SELECT RAISE(ROLLBACK, 'Invalid parameter name');
  END;

  CREATE TRIGGER {{prefix}}_valid_parameter_name_update INSTEAD OF UPDATE ON {{public_prefix}}_parameters
  BEGIN
    SELECT RAISE(ROLLBACK, 'Parameters cannot be modified in place.');
  END;

  {% for parameter_name, parameter_clause in parameters|dictsort %}
    {% if parameter_clause.dictionary %}
      CREATE INDEX {{prefix}}_{{parameter_name}}_actual_key_index ON {{prefix}}_{{parameter_name}}_actual(key);

      CREATE TRIGGER {{prefix}}_delete_{{parameter_name}}_parameters INSTEAD OF DELETE ON {{public_prefix}}_parameters
      WHEN
        old.name = '{{parameter_name}}'
      BEGIN
        DELETE FROM {{prefix}}_{{parameter_name}}_actual WHERE key = old.key;
      END;

      CREATE TRIGGER {{prefix}}_insert_{{parameter_name}}_parameters INSTEAD OF INSERT ON {{public_prefix}}_parameters
      WHEN
        new.name = '{{parameter_name}}'
      BEGIN
        INSERT INTO {{prefix}}_{{parameter_name}}_actual(key, value) VALUES(new.key, new.value);
      END;
    {% else %}
      CREATE TRIGGER {{prefix}}_delete_{{parameter_name}}_parameters INSTEAD OF DELETE ON {{public_prefix}}_parameters
      WHEN
        old.name = '{{parameter_name}}'
      BEGIN
        SELECT RAISE(ROLLBACK, 'Parameter ''{{parameter_name}}'' is single-valued.');
      END;

      CREATE TRIGGER {{prefix}}_insert_with_key_{{parameter_name}}_parameters INSTEAD OF INSERT ON {{public_prefix}}_parameters
      WHEN
        new.name = '{{parameter_name}}' AND new.key IS NOT NULL
      BEGIN
        SELECT RAISE(ROLLBACK, 'Parameter ''{{parameter_name}}'' is single-valued.');
      END;

      CREATE TRIGGER {{prefix}}_insert_{{parameter_name}}_parameters INSTEAD OF INSERT ON {{public_prefix}}_parameters
      WHEN
        new.name = '{{parameter_name}}'
      BEGIN
        DELETE FROM {{prefix}}_{{parameter_name}}_actual;
        INSERT INTO {{prefix}}_{{parameter_name}}_actual(value) VALUES(new.value);
      END;
    {% endif %}
  {% endfor %}
{% endif %}

{# Create the frames tables for each rule. #}
{% for rule_name, rule_clause in rules|dictsort %}
  {# The frames tables for the positive matches. #}
  {% set match_number = 0 %}
  {% for match_clause in rule_clause.matches %}
    CREATE TABLE {{prefix}}_{{rule_name}}_{{match_number}}_frames
    (
      {# The contents of local variables. #}
      {% for variable, type in rule_clause.locals|dictsort %}
        {% if type == bool or type == int %}
          {{variable}} INTEGER,
        {% elif type == float %}
          {{variable}} REAL,
        {% else %}
          {{variable}} TEXT,
        {% endif %}
      {% endfor %}

      {# The facts that have been matched so far. #}
      {% for i in range(0, match_number) %}
        matched_fact_{{i}} INTEGER,
      {% endfor %}

      {# The bookkeeping fields. #}
      {% if match_number > 0 %}
        parent_frame INTEGER REFERENCES {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames(id) ON DELETE CASCADE,
      {% endif %}
      matched_fact_{{match_number}} INTEGER REFERENCES {{prefix}}_{{match_clause.fact}}_actual(id) ON DELETE CASCADE,
      id INTEGER PRIMARY KEY
    );

    CREATE INDEX {{prefix}}_{{rule_name}}_{{match_number}}_alpha_retraction_index ON {{prefix}}_{{rule_name}}_{{match_number}}_frames(matched_fact_{{match_number}});
    {% if match_number > 0 %}
      CREATE INDEX {{prefix}}_{{rule_name}}_{{match_number}}_beta_retraction_index ON {{prefix}}_{{rule_name}}_{{match_number}}_frames(parent_frame);
    {% endif %}

    CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_alpha_activation AFTER INSERT ON {{prefix}}_{{match_clause.fact}}_actual
    WHEN
      {{generate_predicate(match_clause.fact, match_clause.when)}}
    BEGIN
      INSERT INTO {{prefix}}_{{rule_name}}_{{match_number}}_frames
      (
        {% for assignment, value in match_clause.assignments|dictsort %}
          {{assignment}},
        {% endfor %}

        {% for variable, type in rule_clause.locals|dictsort %}
          {% if variable not in match_clause.assignments and match_number > 0 %}
            {{variable}},
          {% endif %}
        {% endfor %}

        {% if match_number > 0 %}
          {% for i in range(0, match_number) %}
            matched_fact_{{i}},
          {% endfor %}

          parent_frame,
        {% endif %}

        matched_fact_{{match_number}}
      )
      SELECT
        {% for assignment, value in match_clause.assignments|dictsort %}
          {{generate_expression(value, match_clause.fact, prefix ~ '_' ~ rule_name ~ '_' ~ (match_number - 1) ~ '_frames', 'new')}},
        {% endfor %}

        {% for variable, type in rule_clause.locals|dictsort %}
          {% if variable not in match_clause.assignments and match_number > 0 %}
            {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames.{{variable}},
          {% endif %}
        {% endfor %}

        {% if match_number > 0 %}
          {% for i in range(0, match_number) %}
            {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames.matched_fact_{{i}},
          {% endfor %}

          {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames.id,
        {% endif %}

        new.id
      {% if match_number > 0 %}
        FROM
          {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames
        {% if generate_join(match_clause.when, match_clause.fact, prefix ~ '_' ~ rule_name ~ '_' ~ (match_number - 1) ~ '_frames', 'new', false) %}
          WHERE
            {{generate_join(match_clause.when, match_clause.fact, prefix ~ '_' ~ rule_name ~ '_' ~ (match_number - 1) ~ '_frames', 'new', false)}}
        {% endif %}
      {% endif %}
      ;
    END;

    {% if match_number > 0 %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_beta_activation AFTER INSERT ON {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames
      BEGIN
        INSERT INTO {{prefix}}_{{rule_name}}_{{match_number}}_frames
        (
          {% for assignment, value in match_clause.assignments|dictsort %}
            {{assignment}}, {# Perform assignments. #}
          {% endfor %}

          {% for variable, type in rule_clause.locals|dictsort %}
            {% if variable not in match_clause.assignments and match_number > 0 %}
              {{variable}}, {# Carry already-assigned or not-yet-assigned variables forward. #}
            {% endif %}
          {% endfor %}

          {% if match_number > 0 %}
            {% for i in range(0, match_number) %}
              matched_fact_{{i}}, {# Carry already-matched fact IDs forward. #}
            {% endfor %}

            parent_frame,
          {% endif %}

          matched_fact_{{match_number}}
        )
        SELECT
          {% for assignment, value in match_clause.assignments|dictsort %}
            {{generate_expression(value, match_clause.fact, 'new', prefix ~ '_' ~ match_clause.fact ~ '_actual')}},
          {% endfor %}

          {% for variable, type in rule_clause.locals|dictsort %}
            {% if variable not in match_clause.assignments and match_number > 0 %}
              new.{{variable}},
            {% endif %}
          {% endfor %}

          {% if match_number > 0 %}
            {% for i in range(0, match_number) %}
              new.matched_fact_{{i}},
            {% endfor %}

            new.id,
          {% endif %}

          {{prefix}}_{{match_clause.fact}}_actual.id
        {% if match_number > 0 %}
          FROM
            {{prefix}}_{{match_clause.fact}}_actual
          {% if generate_join(match_clause.when, match_clause.fact, 'new', prefix ~ '_' ~ match_clause.fact ~ '_actual', true) %}
            WHERE
              {{generate_join(match_clause.when, match_clause.fact, 'new', prefix ~ '_' ~ match_clause.fact ~ '_actual', true)}}
          {% endif %}
        {% endif %}
        ;
      END;
    {% endif %}

    {% set match_number = match_number + 1 %}
  {% endfor %}
  {% set match_number = rule_clause.matches|count %} {# Necessary due to scoping in Jinja. #}

  {# Frames for each of the inverted matches. #}
  {% for match_clause in rule_clause.inverted_matches %}
    CREATE TABLE {{prefix}}_{{rule_name}}_{{match_number}}_frames
    (
      {# The contents of local variables. #}
      {% for variable, type in rule_clause.locals|dictsort %}
        {% if type == bool or type == int %}
          {{variable}} INTEGER,
        {% elif type == float %}
          {{variable}} REAL,
        {% else %}
          {{variable}} TEXT,
        {% endif %}
      {% endfor %}

      {# The facts that have been matched so far. #}
      {% for i in range(0, match_number) %}
        matched_fact_{{i}} INTEGER,
      {% endfor %}

      {# The bookkeeping fields. #}
      parent_frame INTEGER REFERENCES {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames(id) ON DELETE CASCADE,
      matched_fact_{{match_number}} INTEGER, {# The blocking fact. #}
      id INTEGER PRIMARY KEY
    );

    CREATE INDEX {{prefix}}_{{rule_name}}_{{match_number}}_alpha_retraction_index ON {{prefix}}_{{rule_name}}_{{match_number}}_frames(matched_fact_{{match_number}});
    CREATE INDEX {{prefix}}_{{rule_name}}_{{match_number}}_beta_retraction_index ON {{prefix}}_{{rule_name}}_{{match_number}}_frames(parent_frame);

    CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_alpha_activation AFTER INSERT ON {{prefix}}_{{match_clause.fact}}_actual
    WHEN
      {{generate_predicate(match_clause.fact, match_clause.when)}}
    BEGIN
      UPDATE
        {{prefix}}_{{rule_name}}_{{match_number}}_frames
      SET
        matched_fact_{{match_number}} = new.id
      WHERE
        {% if generate_join(match_clause.when, match_clause.fact, prefix ~ '_' ~ rule_name ~ '_' ~ match_number ~ '_frames', 'new', false) %}
          {{generate_join(match_clause.when, match_clause.fact, prefix ~ '_' ~ rule_name ~ '_' ~ match_number ~ '_frames', 'new', false)}} AND
        {% endif %}
        matched_fact_{{match_number}} IS NULL
      ;
    END;

    CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_alpha_retraction AFTER DELETE ON {{prefix}}_{{match_clause.fact}}_actual
    BEGIN
      UPDATE
        {{prefix}}_{{rule_name}}_{{match_number}}_frames
      SET
        matched_fact_{{match_number}} = (SELECT id FROM {{prefix}}_{{match_clause.fact}}_actual
          {% if generate_join(match_clause.when, match_clause.fact, prefix ~ '_' ~ rule_name ~ '_' ~ match_number ~ '_frames', prefix ~ '_' ~ match_clause.fact ~ '_actual', true) %}
            WHERE {{generate_join(match_clause.when, match_clause.fact, prefix ~ '_' ~ rule_name ~ '_' ~ match_number ~ '_frames', prefix ~ '_' ~ match_clause.fact ~ '_actual', true)}}
          {% endif %} LIMIT 1)
      WHERE
        matched_fact_{{match_number}} = old.id
      ;
    END;

    {# If this is the first inverted match, we care about the contents of the previous frame. If it isn't, we just care about whether or not the previous
     # frame (which is an inverted match) lost its blocking status. #}
    {% if match_number == rule_clause.matches|count %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_beta_activation AFTER INSERT ON {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames
      BEGIN
        INSERT INTO {{prefix}}_{{rule_name}}_{{match_number}}_frames
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            {{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            matched_fact_{{i}}, {# Carry already-matched fact IDs forward. #}
          {% endfor %}

          parent_frame,
          matched_fact_{{match_number}}
        )
        VALUES
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            new.{{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            new.matched_fact_{{i}},
          {% endfor %}

          new.id,
          (SELECT id FROM {{prefix}}_{{match_clause.fact}}_actual
            {% if generate_join(match_clause.when, match_clause.fact, 'new', prefix ~ '_' ~ match_clause.fact ~ '_actual', true) %}
              WHERE {{generate_join(match_clause.when, match_clause.fact, 'new', prefix ~ '_' ~ match_clause.fact ~ '_actual', true)}}
            {% endif %} LIMIT 1)
        );
      END;
    {% else %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_beta_activation_after_insert AFTER INSERT ON {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames
      WHEN
        new.matched_fact_{{match_number - 1}} IS NULL
      BEGIN
        INSERT INTO {{prefix}}_{{rule_name}}_{{match_number}}_frames
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            {{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            matched_fact_{{i}}, {# Carry already-matched fact IDs forward. #}
          {% endfor %}

          parent_frame,
          matched_fact_{{match_number}}
        )
        VALUES
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            new.{{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            new.matched_fact_{{i}},
          {% endfor %}

          new.id,
          (SELECT id FROM {{prefix}}_{{match_clause.fact}}_actual
            {% if generate_join(match_clause.when, match_clause.fact, 'new', prefix ~ '_' ~ match_clause.fact ~ '_actual', true) %}
              WHERE {{generate_join(match_clause.when, match_clause.fact, 'new', prefix ~ '_' ~ match_clause.fact ~ '_actual', true)}}
            {% endif %} LIMIT 1)
        );
      END;

      CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_beta_activation_after_update AFTER UPDATE ON {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames
      WHEN
        old.matched_fact_{{match_number - 1}} IS NOT NULL AND new.matched_fact_{{match_number - 1}} IS NULL
      BEGIN
        INSERT INTO {{prefix}}_{{rule_name}}_{{match_number}}_frames
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            {{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            matched_fact_{{i}}, {# Carry already-matched fact IDs forward. #}
          {% endfor %}

          parent_frame,
          matched_fact_{{match_number}}
        )
        VALUES
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            new.{{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            new.matched_fact_{{i}},
          {% endfor %}

          new.id,
          (SELECT id FROM {{prefix}}_{{match_clause.fact}}_actual
            {% if generate_join(match_clause.when, match_clause.fact, 'new', prefix ~ '_' ~ match_clause.fact ~ '_actual', true) %}
              WHERE {{generate_join(match_clause.when, match_clause.fact, 'new', prefix ~ '_' ~ match_clause.fact ~ '_actual', true)}}
            {% endif %} LIMIT 1)
        );
      END;
    {% endif %}

    {# If the previous match is a blocking match, we need to delete this frame if the block goes positive.
     # We don't need to worry about the frame being deleted; foreign keys handle that for us. #}
    {% if match_number > rule_clause.matches|count %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_beta_retraction AFTER UPDATE ON {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames
      WHEN
        new.matched_fact_{{match_number - 1}} IS NOT NULL
      BEGIN
        DELETE FROM {{prefix}}_{{rule_name}}_{{match_number}}_frames WHERE parent_frame = new.id;
      END;
    {% endif %}

    {% set match_number = match_number + 1 %}
  {% endfor %}
  {% set match_number = rule_clause.matches|count + rule_clause.inverted_matches|count %}

  {# If this rule has a distinct production, we add an additional frame here to track the potentially blocking distinct facts. #}
  {% if rule_clause.distinct %}
    CREATE TABLE {{prefix}}_{{rule_name}}_{{match_number}}_frames
    (
      {# The contents of local variables. #}
      {% for variable, type in rule_clause.locals|dictsort %}
        {% if type == bool or type == int %}
          {{variable}} INTEGER,
        {% elif type == float %}
          {{variable}} REAL,
        {% else %}
          {{variable}} TEXT,
        {% endif %}
      {% endfor %}

      {# The facts that have been matched so far. #}
      {% for i in range(0, match_number) %}
        matched_fact_{{i}} INTEGER,
      {% endfor %}

      {# The bookkeeping fields. #}
      parent_frame INTEGER REFERENCES {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames(id) ON DELETE CASCADE,
      matched_fact_{{match_number}} INTEGER, {# The distinct fact. #}
      id INTEGER PRIMARY KEY
    );

    CREATE INDEX {{prefix}}_{{rule_name}}_{{match_number}}_alpha_retraction_index ON {{prefix}}_{{rule_name}}_{{match_number}}_frames(matched_fact_{{match_number}});
    CREATE INDEX {{prefix}}_{{rule_name}}_{{match_number}}_beta_retraction_index ON {{prefix}}_{{rule_name}}_{{match_number}}_frames(parent_frame);

    CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_alpha_retraction AFTER DELETE ON {{prefix}}_{{rule_clause.produced_fact}}_actual
    BEGIN
      UPDATE
        {{prefix}}_{{rule_name}}_{{match_number}}_frames
      SET
        matched_fact_{{match_number}} = (SELECT ID FROM {{prefix}}_{{rule_clause.produced_fact}}_actual
                                           {% if facts[rule_clause.produced_fact]|count > 0 %}
                                             WHERE
                                               {% set join_and = joiner(" AND ") %}
                                               {% for field_name, field_type in facts[rule_clause.produced_fact]|dictsort %}
                                                   {{join_and()}}
                                                   {{field_name}} = {{generate_expression(rule_clause.produced_fields[field_name], rule_clause.produced_fact,
                                                                                          prefix ~ '_' ~ rule_name ~ '_' ~ match_number ~ '_frames', 'old')}}
                                               {% endfor %}
                                           {% endif %} LIMIT 1)
      WHERE
        matched_fact_{{match_number}} = old.id
      ;
    END;

    {# If there is an inverted match, we want to copy the contents of the previous frame when it's inserted. Otherwise, we want to copy it when the
     # blocking status is lost. #}
    {% if rule_clause.inverted_matches|count == 0 %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_beta_activation AFTER INSERT ON {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames
      BEGIN
        INSERT INTO {{prefix}}_{{rule_name}}_{{match_number}}_frames
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            {{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            matched_fact_{{i}}, {# Carry already-matched fact IDs forward. #}
          {% endfor %}

          parent_frame,
          matched_fact_{{match_number}}
        )
        VALUES
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            new.{{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            new.matched_fact_{{i}},
          {% endfor %}

          new.id,
          (SELECT ID FROM {{prefix}}_{{rule_clause.produced_fact}}_actual
            {% if facts[rule_clause.produced_fact]|count > 0 %}
              WHERE
                {% set join_and = joiner(" AND ") %}
                {% for field_name, field_type in facts[rule_clause.produced_fact]|dictsort %}
                    {{join_and()}}
                    {{field_name}} = {{generate_expression(rule_clause.produced_fields[field_name], rule_clause.produced_fact, 'new', 'new')}}
                {% endfor %}
            {% endif %} LIMIT 1)
        );
      END;
    {% else %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_beta_activation_after_insert AFTER INSERT ON {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames
      WHEN
        new.matched_fact_{{match_number - 1}} IS NULL
      BEGIN
        INSERT INTO {{prefix}}_{{rule_name}}_{{match_number}}_frames
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            {{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            matched_fact_{{i}}, {# Carry already-matched fact IDs forward. #}
          {% endfor %}

          parent_frame,
          matched_fact_{{match_number}}
        )
        VALUES
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            new.{{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            new.matched_fact_{{i}},
          {% endfor %}

          new.id,
          (SELECT ID FROM {{prefix}}_{{rule_clause.produced_fact}}_actual
            {% if facts[rule_clause.produced_fact]|count > 0 %}
              WHERE
                {% set join_and = joiner(" AND ") %}
                {% for field_name, field_type in facts[rule_clause.produced_fact]|dictsort %}
                    {{join_and()}}
                    {{field_name}} = {{generate_expression(rule_clause.produced_fields[field_name], rule_clause.produced_fact, 'new', 'new')}}
                {% endfor %}
            {% endif %} LIMIT 1)
        );
      END;

      CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_beta_activation_after_update AFTER UPDATE ON {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames
      WHEN
        old.matched_fact_{{match_number - 1}} IS NOT NULL AND new.matched_fact_{{match_number - 1}} IS NULL
      BEGIN
        INSERT INTO {{prefix}}_{{rule_name}}_{{match_number}}_frames
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            {{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            matched_fact_{{i}}, {# Carry already-matched fact IDs forward. #}
          {% endfor %}

          parent_frame,
          matched_fact_{{match_number}}
        )
        VALUES
        (
          {% for variable, type in rule_clause.locals|dictsort %}
            new.{{variable}},
          {% endfor %}

          {% for i in range(0, rule_clause.matches|count) %}
            new.matched_fact_{{i}},
          {% endfor %}

          new.id,
          (SELECT ID FROM {{prefix}}_{{rule_clause.produced_fact}}_actual
            {% if facts[rule_clause.produced_fact]|count > 0 %}
              WHERE
                {% set join_and = joiner(" AND ") %}
                {% for field_name, field_type in facts[rule_clause.produced_fact]|dictsort %}
                    {{join_and()}}
                    {{field_name}} = {{generate_expression(rule_clause.produced_fields[field_name], rule_clause.produced_fact, 'new', 'new')}}
                {% endfor %}
            {% endif %} LIMIT 1)
        );
      END;
    {% endif %}

    {# If the previous match is a blocking match, we need to delete this frame if the block goes positive.
     # We don't need to worry about the frame being deleted; foreign keys handle that for us. #}
    {% if rule_clause.inverted_matches|count > 0 %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_{{match_number}}_beta_retraction AFTER UPDATE ON {{prefix}}_{{rule_name}}_{{match_number - 1}}_frames
      WHEN
        new.matched_fact_{{match_number - 1}} IS NOT NULL
      BEGIN
        DELETE FROM {{prefix}}_{{rule_name}}_{{match_number}}_frames WHERE parent_frame = new.id;
      END;
    {% endif %}
  {% endif %}

  {% set match_number = rule_clause.matches|count - 1 %}
  {% if rule_clause.inverted_matches|count > 0 %}
    {% set match_number = match_number + rule_clause.inverted_matches|count %}
  {% endif %}
  {% if rule_clause.distinct %}
    {% set match_number = match_number + 1 %}
  {% endif %}

  {# Do the special handling for the last match, which is to take the action specified for the rule. #}
  {% if "produced_fact" in rule_clause %} {# We're producing a new fact. #}
    CREATE TRIGGER {{prefix}}_{{rule_name}}_fire_productions_after_insert AFTER INSERT ON {{prefix}}_{{rule_name}}_{{match_number}}_frames
      WHEN ({{generate_expression(rule_clause.final_predicate, rule_clause.produced_fact, 'new', None)}})
      {% if rule_clause.inverted_matches|count > 0 or rule_clause.distinct %}
        AND (new.matched_fact_{{match_number}} IS NULL)
      {% endif %}
    BEGIN
      INSERT INTO {{prefix}}_{{rule_clause.produced_fact}}_actual
      (
        {% for field_name, type in facts[rule_clause.produced_fact]|dictsort %}
            {{field_name}},
        {% endfor %}

        rule,
        frame
      )
      VALUES
      (
        {% for field_name, type in facts[rule_clause.produced_fact]|dictsort %}
            {{generate_expression(rule_clause.produced_fields[field_name], rule_clause.produced_fact, 'new', None)}},
        {% endfor %}

        '{{rule_name}}',
        new.id
      );
    END;

    {% if rule_clause.inverted_matches|count > 0 or rule_clause.distinct %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_fire_productions_after_update AFTER UPDATE ON {{prefix}}_{{rule_name}}_{{match_number}}_frames
      WHEN
          {{generate_expression(rule_clause.final_predicate, rule_clause.produced_fact, 'new', None)}}
        AND
          new.matched_fact_{{match_number}} IS NULL
      BEGIN
        INSERT INTO {{prefix}}_{{rule_clause.produced_fact}}_actual
        (
          {% for field_name, type in facts[rule_clause.produced_fact]|dictsort %}
              {{field_name}},
          {% endfor %}

          rule,
          frame
        )
        VALUES
        (
          {% for field_name, type in facts[rule_clause.produced_fact]|dictsort %}
              {{generate_expression(rule_clause.produced_fields[field_name], rule_clause.produced_fact, 'new', None)}},
          {% endfor %}

          '{{rule_name}}',
          new.id
        );
      END;
    {% endif %}

    {# Facts go away if this frame is deleted. #}
    CREATE TRIGGER {{prefix}}_{{rule_name}}_retract_productions AFTER DELETE ON {{prefix}}_{{rule_name}}_{{match_number}}_frames
    BEGIN
      DELETE FROM {{prefix}}_{{rule_clause.produced_fact}}_actual WHERE rule = '{{rule_name}}' AND frame == old.id;
      DELETE FROM {{prefix}}_{{rule_clause.produced_fact}}_shadow WHERE rule = '{{rule_name}}' AND frame == old.id;
    END;

    {# For distinct productions and blocking matches, facts go away if the blocking fact becomes non-null. #}
    {# If there are inverted matches, facts go away if one of the blocking counters becomes positive. #}
    {% if rule_clause.inverted_matches|count > 0 %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_block_productions AFTER UPDATE ON {{prefix}}_{{rule_name}}_{{match_number}}_frames
      WHEN
        old.matched_fact_{{match_number}} IS NULL AND new.matched_fact_{{match_number}} IS NOT NULL
      BEGIN
        DELETE FROM {{prefix}}_{{rule_clause.produced_fact}}_actual WHERE rule = '{{rule_name}}' AND frame = old.id;
        DELETE FROM {{prefix}}_{{rule_clause.produced_fact}}_shadow WHERE rule = '{{rule_name}}' AND frame = old.id;
      END;
    {% endif %}
  {% endif %}

  {% if "suppressed_fact" in rule_clause %} {# We're suppressing old facts. #}
    CREATE TRIGGER {{prefix}}_{{rule_name}}_suppress_after_insert AFTER INSERT ON {{prefix}}_{{rule_name}}_{{match_number}}_frames
      WHEN ({{generate_expression(rule_clause.final_predicate, rule_clause.produced_fact, 'new', None)}})
      {% if rule_clause.inverted_matches|count > 0 or rule_clause.distinct %}
        AND new.matched_fact_{{match_number}} IS NULL
      {% endif %}
    BEGIN
      {# Mark and sweep. NOTE - This is kinda ugly and only works on systems where triggers don't execute in parallel, like SQLite. #}
      UPDATE
        {{prefix}}_{{rule_clause.suppressed_fact}}_actual
      SET
        suppressed = 1
      {% if generate_join(rule_clause.suppressed_when, rule_clause.suppressed_fact, 'new', prefix ~ '_' ~ rule_clause.suppressed_fact ~ '_actual', true) %}
         WHERE
           {{generate_join(rule_clause.suppressed_when, rule_clause.suppressed_fact, 'new', prefix ~ '_' ~ rule_clause.suppressed_fact ~ '_actual', true)}}
      {% endif %}
      ;

      INSERT INTO {{prefix}}_{{rule_clause.suppressed_fact}}_shadow
      (
        {% for field_name, field_type in facts[rule_clause.suppressed_fact]|dictsort %}
          {{field_name}},
        {% endfor %}

        rule,
        frame,
        suppressing_rule,
        suppressing_frame
      )
      SELECT
        {% for field_name, field_type in facts[rule_clause.suppressed_fact]|dictsort %}
          {{field_name}},
        {% endfor %}

        rule,
        frame,

        '{{rule_name}}',
        new.id
      FROM
        {{prefix}}_{{rule_clause.suppressed_fact}}_actual AS fact
      WHERE
        suppressed
      ;

      DELETE FROM {{prefix}}_{{rule_clause.suppressed_fact}}_actual WHERE suppressed;
    END;

    {% if rule_clause.inverted_matches|count > 0 or rule_clause.distinct %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_fire_productions_after_update AFTER UPDATE ON {{prefix}}_{{rule_name}}_{{match_number}}_frames
      WHEN
          ({{generate_expression(rule_clause.final_predicate, rule_clause.produced_fact, 'new', None)}})
        AND
          old.matched_fact_{{matched_fact}} IS NOT NULL AND new.matched_fact_{{matched_fact}} IS NULL
      BEGIN
        {# Mark and sweep. NOTE - This is kinda ugly and only works on systems where triggers don't execute in parallel, like SQLite. #}
        UPDATE
          {{prefix}}_{{rule_clause.suppressed_fact}}_actual
        SET
          suppressed = 1
        {% if generate_join(rule_clause.suppressed_when, rule_clause.suppressed_fact, 'new', prefix ~ '_' ~ rule_clause.suppressed_fact ~ '_actual', true) %}
           WHERE
             {{generate_join(rule_clause.suppressed_when, rule_clause.suppressed_fact, 'new', prefix ~ '_' ~ rule_clause.suppressed_fact ~ '_actual', true)}}
        {% endif %}
        ;

        INSERT INTO {{prefix}}_{{rule_clause.suppressed_fact}}_shadow
        (
          {% for field_name, field_type in facts[rule_clause.suppressed_fact]|dictsort %}
            {{field_name}},
          {% endfor %}

          rule,
          frame,
          suppressing_rule,
          suppressing_frame
        )
        SELECT
          {% for field_name, field_type in facts[rule_clause.suppressed_fact]|dictsort %}
            {{field_name}},
          {% endfor %}

          rule,
          frame,

          '{{rule_name}}',
          new.id
        FROM
          {{prefix}}_{{rule_clause.suppressed_fact}}_actual AS fact
        WHERE
          suppressed
        ;

        DELETE FROM {{prefix}}_{{rule_clause.suppressed_fact}}_actual WHERE suppressed;
      END;
    {% endif %}

    {# Facts come back if this frame is deleted. #}
    CREATE TRIGGER {{prefix}}_{{rule_name}}_restore_productions AFTER DELETE ON {{prefix}}_{{rule_name}}_{{match_number}}_frames
    BEGIN
      INSERT INTO {{prefix}}_{{rule_clause.suppressed_fact}}_actual
      (
        {% for field_name, field_type in facts[rule_clause.suppressed_fact]|dictsort %}
          {{field_name}},
        {% endfor %}

        rule,
        frame
      )
      SELECT
        {% for field_name, field_type in facts[rule_clause.suppressed_fact]|dictsort %}
          {{field_name}},
        {% endfor %}

        rule,
        frame
      FROM
        {{prefix}}_{{rule_clause.suppressed_fact}}_shadow
      WHERE
        suppressing_rule = '{{rule_name}}' AND suppressing_frame = old.id
      ;

      DELETE FROM {{prefix}}_{{rule_clause.suppressed_fact}}_shadow WHERE suppressing_rule = '{{rule_name}}' AND suppressing_frame = old.id;
    END;

    {# If there are inverted matches, facts come back if one of the blocking counters becomes positive. #}
    {% if rule_clause.inverted_matches|count > 0 %}
      CREATE TRIGGER {{prefix}}_{{rule_name}}_block_suppressions AFTER UPDATE ON {{prefix}}_{{rule_name}}_{{match_number}}_frames
      WHEN
        old.matched_fact_{{match_number}} IS NULL AND new.matched_fact_{{match_number}} IS NOT NULL
      BEGIN
        INSERT INTO {{prefix}}_{{rule_clause.suppressed_fact}}_actual
        (
          {% for field_name, field_type in facts[rule_clause.suppressed_fact]|dictsort %}
            {{field_name}},
          {% endfor %}

          rule,
          frame
        )
        SELECT
          {% for field_name, field_type in facts[rule_clause.suppressed_fact]|dictsort %}
            {{field_name}},
          {% endfor %}

          rule,
          frame
        FROM
          {{prefix}}_{{rule_clause.suppressed_fact}}_shadow
        WHERE
          suppressing_rule = '{{rule_name}}' AND suppressing_frame = old.id
        ;

        DELETE FROM {{prefix}}_{{rule_clause.suppressed_fact}}_shadow WHERE suppressing_rule = '{{rule_name}}' AND suppressing_frame = old.id;
      END;
    {% endif %}

    {# We need to suppress any new facts if they match an open suppressing frame. #}
    CREATE TRIGGER {{prefix}}_{{rule_name}}_suppress_ab_initio AFTER INSERT ON {{prefix}}_{{rule_clause.suppressed_fact}}_actual
    WHEN
        {{generate_predicate(facts[rule_clause.suppressed_fact], rule_clause.suppressed_when)}}
        {% if generate_join(rule_clause.suppressed_when, rule_clause.suppressed_fact, prefix ~ '_' ~ rule_name ~ '_' ~ match_number ~ '_frames', 'new', false) %}
          AND EXISTS(
            SELECT
               1
             FROM
               {{prefix}}_{{rule_name}}_{{match_number}}_frames
             WHERE
               {{generate_join(rule_clause.suppressed_when, rule_clause.suppressed_fact, prefix ~ '_' ~ rule_name ~ '_' ~ match_number ~ '_frames', 'new', false)}}
            )
        {% endif %}
    BEGIN
      INSERT INTO {{prefix}}_{{rule_clause.suppressed_fact}}_shadow
      (
        {% for field_name, field_type in facts[rule_clause.suppressed_fact]|dictsort %}
          {{field_name}},
        {% endfor %}

        rule,
        frame,
        suppressing_rule,
        suppressing_frame
      )
      SELECT
        {% for field_name, field_type in facts[rule_clause.suppressed_fact]|dictsort %}
          {{field_name}},
        {% endfor %}

        rule,
        frame,

        '{{rule_name}}',
        (SELECT
           id
         FROM
           {{prefix}}_{{rule_name}}_{{match_number}}_frames
         {% if generate_join(rule_clause.suppressed_when, rule_clause.suppressed_fact, prefix ~ '_' ~ rule_name ~ '_' ~ match_number ~ '_frames', 'new', false) %}
           WHERE
             {{generate_join(rule_clause.suppressed_when, rule_clause.suppressed_fact, prefix ~ '_' ~ rule_name ~ '_' ~ match_number ~ '_frames', 'new', false)}}
         {% endif %}
         LIMIT 1)
      FROM
        {{prefix}}_{{rule_clause.suppressed_fact}}_actual AS fact
      WHERE
        id = new.id
      ;

      DELETE FROM {{prefix}}_{{rule_clause.suppressed_fact}}_actual WHERE id = new.id;
    END;
  {% endif %}
{% endfor %}

{# Justification is handled via a nice view. #}
{% for fact_name, fact_clause in facts|dictsort %}
  CREATE VIEW {{public_prefix}}_{{fact_name}}_justification AS
    SELECT
      id,
      (CASE
        WHEN 0 THEN 'Unknown justification.'
        {% for rule_name, rule_clause in rules|dictsort %}
          {% if fact_name == rule_clause.produced_fact %}
            WHEN rule == '{{rule_name}}' THEN
               'Fact ''{{fact_name}}'' #' || id || ' was produced by rule ''{{rule_name}}'':
               {{rule_clause.description.replace("'", "''")}}

               Justification:
               {% set i = 0 %}
               {% for match_clause in rule_clause.matches %}
                 * {{match_clause.meaning.replace("'", "''")}} ({{match_clause.fact}} #' ||
                                                                (SELECT matched_fact_{{i}} FROM {{prefix}}_{{rule_name}}_{{rule_clause.matches|count + rule_clause.inverted_matches|count - 1}}_frames WHERE id = frame) || ')
                 {% set i = i + 1 %}
               {% endfor %}
               {% for match_clause in rule_clause.inverted_matches %}
                 * {{match_clause.meaning.replace("'", "''")}}
               {% endfor %}'
            {% endif %}
          {% endfor %}
        ELSE 
          {% if fact_name in parameters %}
            'Fact ''{{fact_name}}'' #' || id || ' is a parameter.'
          {% else %}
            'Fact ''{{fact_name}}'' #' || id || ' was injected from an external source.'
          {% endif %}
      END) AS justification
    FROM {{prefix}}_{{fact_name}}_actual;
{% endfor %}

{# Insert the default values for the various parameters. We do this after all the rules
 # have been defined so that we automatically get frames opened as needed. #}
{% for parameter_name, parameter_clause in parameters|dictsort %}
  {% if not parameter_clause.dictionary %}
    INSERT INTO {{prefix}}_{{parameter_name}}_actual
    (
      Value
    )
    VALUES
    (
      {{generate_expression(parameter_clause.default, parameter_name, None)}}
    );
  {% endif %}
{% endfor %}

{# Insert an initial fact. #}
INSERT INTO {{public_prefix}}_InitialFact_facts(InitializationTime) VALUES(CAST(strftime('%s', 'now') AS INTEGER));

{# We want to support engine upgrades, meaning we want to copy all of the
 # needed information from one database to another, possibly with two
 # different schemas.
 #
 # Because the schemas could be different, we have to define a lowest-common-denominator
 # format which, for the SQLite backend, is key-value pairs.
 # We dump the contents of the first database as a series of fact_type-field-value triples
 # and insert them in this table. When we've finished inserting an fact, we insert
 # a record with its fact_type and fact_id with a true "complete" flag.
 # This will cause our upgrade triggers to pick up on that fact and insert it.
 # The upgrade triggers will handle default values if the new schema defines a field that
 # wasn't in the old one.
 #
 # This is further complicated by the prohibition by SQLite that qualified tables
 # can't appear in INSERT, DELETE, or UPDATE statements in trigger programs.
 # So, the upgrade process looks like this:
 #
 # - Serialize a database to its {{prefix}}_serialization_source table.
 # - Attach the source database to the destination database.
 # - Copy the contents of the {{prefix}}_serialization_source table to the main.destination database.
 #}

CREATE TABLE {{public_prefix}}_serialization_destination
(
  fact_type TEXT,
  fact_id   INTEGER,
  field      TEXT,
  value      TEXT,
  complete   INTEGER
);

CREATE INDEX {{prefix}}_serialization_destination_id_field ON {{public_prefix}}_serialization_destination(fact_id, field);

CREATE TRIGGER {{prefix}}_serialization_ignore_unknown_facts BEFORE INSERT ON {{public_prefix}}_serialization_destination
WHEN
  new.fact_type NOT IN
  (
    {% set comma = joiner(",") %}
    {% for fact_name, fact_clause in facts|dictsort %}
      {{comma()}}
      '{{fact_name}}'
    {% endfor %}
  )
BEGIN
  SELECT RAISE(IGNORE);
END;

{% for fact_name, fact_clause in facts|dictsort %}
  CREATE TRIGGER {{prefix}}_serialization_perform_insert_{{fact_name}} AFTER INSERT ON {{public_prefix}}_serialization_destination
  WHEN
    new.complete AND new.fact_type = '{{fact_name}}'
  BEGIN
    {% if fact_name in parameters %}
      INSERT INTO {{public_prefix}}_parameters
      (
        name,
        {% if parameters[fact_name].dictionary %}
          key,
        {% endif %}
        value
      )
      VALUES
      (
        '{{fact_name}}',
        {% if parameters[fact_name].dictionary %}
          (SELECT value FROM {{public_prefix}}_serialization_destination WHERE fact_id = new.fact_id AND lower(field) = 'key' LIMIT 1),
        {% endif %}
        {% if facts[fact_name].value == int or facts[fact_name].value == bool %}
          CAST((SELECT value FROM {{public_prefix}}_serialization_destination WHERE fact_id = new.fact_id AND lower(field) = 'value') AS INTEGER)
        {% elif facts[fact_name].value == float %}
          CAST((SELECT value FROM {{public_prefix}}_serialization_destination WHERE fact_id = new.fact_id AND lower(field) = 'value') AS REAL)
        {% else %}
          (SELECT value FROM {{public_prefix}}_serialization_destination WHERE fact_id = new.fact_id AND lower(field) = 'value')
        {% endif %}
      );
    {% else %}
      INSERT INTO {{prefix}}_{{fact_name}}_actual
      (
        {% set comma = joiner(",") %}
        {% for field_name, field_type in fact_clause|dictsort %}
          {{comma()}}
          {{field_name}}
        {% endfor %}
      )
      VALUES
      (
        {% set comma = joiner(",") %}
        {% for field_name, field_type in fact_clause|dictsort %}
          {{comma()}}
          {% if field_type == int or field_type == bool %}
            COALESCE((SELECT CAST(value AS INTEGER) FROM {{public_prefix}}_serialization_destination WHERE fact_id = new.fact_id AND field = '{{field_name}}'), 0)
          {% elif field_type == float %}
            COALESCE((SELECT CAST(value AS REAL) FROM {{public_prefix}}_serialization_destination WHERE fact_id = new.fact_id AND field = '{{field_name}}'), 0.0)
          {% else %}
            COALESCE((SELECT value FROM {{public_prefix}}_serialization_destination WHERE fact_id = new.fact_id AND field = '{{field_name}}'), '')
          {% endif %}
        {% endfor %}
      );
    {% endif %}

    DELETE FROM {{public_prefix}}_serialization_destination WHERE fact_id = new.fact_id;
  END;
{% endfor %}

{# Now for the local serialization side. #}

CREATE TABLE {{public_prefix}}_serialization_source
(
  fact_type TEXT,
  fact_id   INTEGER,
  field      TEXT,
  value      TEXT,
  complete   INTEGER
);

CREATE INDEX {{prefix}}_serialization_source_id_field ON {{public_prefix}}_serialization_source(fact_id, field);

CREATE VIEW {{public_prefix}}_do_serialization AS SELECT NULL;

CREATE TRIGGER {{prefix}}_do_upgrade_serialization INSTEAD OF INSERT ON {{public_prefix}}_do_serialization
BEGIN
  DELETE FROM {{public_prefix}}_serialization_source;

  {% for fact_name, fact_clause in facts|dictsort %}
    {% for field_name, field_type in fact_clause|dictsort %}
      INSERT INTO {{public_prefix}}_serialization_source
      (
        fact_type,
        fact_id,
        field,
        value,
        complete
      )
      SELECT
        '{{fact_name}}',
        id,
        '{{field_name}}',
        CAST({{field_name}} AS TEXT),
        0
      FROM
        {{prefix}}_{{fact_name}}_actual
      WHERE
        frame IS NULL
      ;
    {% endfor %}

    INSERT INTO {{public_prefix}}_serialization_source
    (
      fact_type,
      fact_id,
      complete
    )
    SELECT
      '{{fact_name}}',
      id,
      1
    FROM
      {{prefix}}_{{fact_name}}_actual
    WHERE
      frame IS NULL
    ;
  {% endfor %}
END;
